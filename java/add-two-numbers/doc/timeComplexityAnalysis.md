## 时间复杂度分析

## 单次运算分析

### 算法上下界

|  算法/操作 | constructor()     | getProp()          | setProp()           |
|------------|-------------------|--------------------|---------------------|
|  直接同步  | O(n)              | O(1)               | O(n)                |
|  需时同步  | O(1)              | O(1) ~ O(n)        | O(1)                |

- 注1： 变量n具体是指这次更新链表的链表长度


## 多次运算分析

| 算法             | 直接同步                  | 需时同步                   |
|------------------|---------------------------|----------------------------|
| 摊还成本         | O(1) ~ O(n)               |                            |

### 模型抽象

对象`digitStringList`多次操作可以抽象为:

```
<-- 构造过程0 -->  <-- get操作组0 -->  <-- set操作组0 -->  <-- get操作组1 -->  <-- set操作组0 -->
    construct0,   [get00, get01 ...], [set00, set01 ...], [get10, get11 ...], [set10, set11 ...] ...
```

- 注1： 其中`get`操作和`set`操作组顺序可以任意组合，每组包含操作可以有任意多个

### 分析过程

总时间成本:

```
fn(n) = c0 + ∑(g01 + ... + g0n) + Σ(s00 + ... + s0n) +  ...

```

- 注1：fn(n)中的n是总的操作的个数
- 注3： 一个变量的生命周期只会存在一次构造过程，构造时间就是c0
- 注2： 其中变量c0指第一次构造函数时间，g00是第零组第零次操作的时间, s00是第零组第零次的时间

### 摊还成本

### 直接同步

总时间成本:

```
fn(n) = c0 + gn * 1 + ∑(s00 + ... + s0n + ... + sn0 + ... + snn)
```

- 注1：fn(n)中的n是总的操作的个数
- 注2：gn是所有get操作的总个数，其中每个get操作的成本是1

特殊情况:

```
fn(n) = (c0 + gn ) * 1 + sn * st
```

- 注1: 其中如果假设所有set操作的时间是st,set操作总成本为`sn * st`

摊还代价:

```
((O(n) + (n - 1) * O(1))/n <= (( 1 + gn ) * O(1) + sn * O(k))/n <= (n * O(k))/n
```

### 需时同步
